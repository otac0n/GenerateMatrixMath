@namespace GenerateMatrixMath
@using GenerateMatrixMath.Model
@model Vector
{{
    var size = model.Size;
    var fields = Vector.VectorFieldNames.Take(size);
    var thisType = new { Name = "Vector", model.Size, model.Integral };
}}
namespace Silk.NET.Maths
{
    using System.Collections;
    using System.Diagnostics.CodeAnalysis;
    using System.Numerics;

    partial struct {{@Name thisType}}<T> :
        IEquatable<{{@Name thisType}}<T>>,
        IReadOnlyList<T>
        where T : {{if model.Integral}}IBinaryInteger{{else}}IFloatingPointIeee754{{/if}}<T>
    {
        {{each f in fields}}
            /// <summary>The {{= f}} component of the vector.</summary>
            public T {{= f}};

        {{/each}}
        /// <summary>Initializes all components of the vector to the same value.</summary>
        public {{@Name thisType}}(T value) => ({{each f in fields}}{{= f}}{{delimit}}, {{/each}}) = ({{each f in fields}}value{{delimit}}, {{/each}});

        /// <summary>Initializes the vector with individual component values.</summary>
        public {{@Name thisType}}({{each f in fields}}T {{= f.ToLower()}}{{delimit}}, {{/each}}) => ({{each f in fields}}{{= f}}{{delimit}}, {{/each}}) = ({{each f in fields}}{{= f.ToLower()}}{{delimit}}, {{/each}});

        /// <inheritdoc/>
        T IReadOnlyList<T>.this[int index] => this[index];

        ///<summary>Gets the component at the specified index: {{each i in Enumerable.Range(0, size)}}{{= i}} = {{= Vector.VectorFieldNames[i]}}{{delimit}}, {{/each}}. </summary>
        [UnscopedRef]
        public ref T this[int index]
        {
            get
            {
                switch (index)
                {
                    {{each i in Enumerable.Range(0, size)}}
                        case {{= i}}:
                            return ref {{= Vector.VectorFieldNames[i]}};
                    {{/each}}
                }

                throw new ArgumentOutOfRangeException(nameof(index));
            }
        }

        /// <summary>The number of elements in the vector.</summary>
        public int Count => {{= size}};

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary> Returns an enumerator that iterates through the vector components.</summary>
        public IEnumerator<T> GetEnumerator()
        {
            {{each field in fields}}
                yield return {{= field}};
            {{/each}}
        }

        /// <summary>Returns a boolean indicating whether the given two vectors are equal.</summary>
        /// <param name="left">The first vector to compare.</param>
        /// <param name="right">The second vector to compare.</param>
        /// <returns><c>true</c> if the given vectors are equal; <c>false</c> otherwise.</returns>
        public static bool operator ==({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) =>
            {{each f in fields}}left.{{= f}} == right.{{= f}}{{delimit}} &&
            {{/each}};

        /// <summary>Returns a boolean indicating whether the given two vectors are not equal.</summary>
        /// <param name="left">The first vector to compare.</param>
        /// <param name="right">The second vector to compare.</param>
        /// <returns><c>true</c> if the given vectors are not equal; <c>false</c> otherwise.</returns>
        public static bool operator !=({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) => !(left == right);

        /// <inheridoc/>
        public override bool Equals(object? obj) => obj is {{@Name thisType}}<T> other && Equals(other);

        /// <inheridoc/>
        public bool Equals({{@Name thisType}}<T> other) => this == other;

        /// <inheridoc/>
        public override int GetHashCode() => HashCode.Combine({{each f in fields}}{{= f}}{{delimit}}, {{/each}});
    }

    static partial class {{@Name thisType}}
    {
        {{each inter in model.Interfaces}}
            {{
                var t = inter.GetGenericArguments().Single();
                var interName = inter.Name;
                var backTickIndex = interName.IndexOf('`');
                if (backTickIndex > 0)
                {
                    interName = interName.Substring(0, backTickIndex);
                }
            }}
            {{each method in inter.GetMethods()}}
                public static {{@Name thisType}}<{{= t}}> {{= method.Name}}<{{= t}}>(this {{each p in method.GetParameters()}}{{@Name thisType}}<{{= p.ParameterType}}> {{= p.Name}}{{delimit}}, {{/each}})
                    where {{= t}} : {{if model.Integral}}IBinaryInteger{{else}}IFloatingPointIeee754{{/if}}<{{= t}}>, {{= interName}}<{{= t}}> =>
                    new({{each f in fields}}{{= t}}.{{= method.Name}}({{each p in method.GetParameters()}}{{= p.Name}}.{{= f}}{{delimit}}, {{/each}}){{delimit}}, {{/each}});
            {{delimit}}

            {{/each}}
        {{delimit}}

        {{/each}}
    }
}
