@namespace GenerateMatrixMath
@using GenerateMatrixMath.Model
@model Matrix
{{
    var size = model.Size;
    var rows = Enumerable.Range(1, size.Rows);
    var cols = Enumerable.Range(1, size.Columns);

    var thisType = new { Name = "Matrix", model.Size };
    var rowType = new { Name = "Vector", Size = size.Columns };
    var columnType = new { Name = "Vector", Size = size.Rows };
}}
namespace Silk.NET.Maths
{
    using System.Diagnostics.CodeAnalysis;
    using System.Numerics;
    using System.Runtime.CompilerServices;
    using System.Runtime.Serialization;

    public partial struct {{@Name thisType}}<T> :
        IEquatable<{{@Name thisType}}<T>>
        where T : INumberBase<T>
    {
        {{if size.Rows == size.Columns}}
            /// <summary>The multiplicative identity matrix of size {{= size}}.</summary>
            public static {{@Name thisType}}<T> Identity { get; } = new({{each r in rows}}
                new({{each c in cols}}{{if r == c}}T.MultiplicativeIdentity{{else}}T.Zero{{/if}}{{delimit}}, {{/each}}){{delimit}},{{/each}});

        {{/if}}
        {{each r in rows}}
            /// <summary>The {{@Ordinal r}} row of the matrix represented as a vector.</summary>
            [IgnoreDataMember]
            public {{@Name rowType}}<T> Row{{= r}};

        {{/each}}
        {{if size.Rows < 5}}
            {{each c in cols}}
                /// <summary>The {{@Ordinal c}} column of the matrix represented as a vector.</summary>
                [IgnoreDataMember]
                public {{@Name columnType}}<T> Column{{= c}} => new({{each r in rows}}Row{{= r}}.{{= Vector.VectorFieldNames[c - 1]}}{{delimit}}, {{/each}});

            {{/each}}
        {{/if}}
        /// <summary>
        /// Constructs a <see cref="{{@Name thisType}}{T}"/> from the given rows.
        /// </summary>
        public {{@Name thisType}}({{each r in rows}}{{@Name rowType}}<T> row{{= r}}{{delimit}}, {{/each}}) =>
            ({{each r in rows}}Row{{= r}}{{delimit}}, {{/each}}) = ({{each r in rows}}row{{= r}}{{delimit}}, {{/each}});

        /// <summary>
        /// Constructs a <see cref="{{@Name thisType}}{T}"/> from the given components.
        /// </summary>
        public {{@Name thisType}}(
            {{each r in rows}}{{each c in cols}}T m{{= r}}{{= c}}{{delimit}}, {{/each}}{{delimit}},
            {{/each}})
        {
            {{each r in rows}}
                Row{{= r}} = new({{each c in cols}}m{{= r}}{{= c}}{{delimit}}, {{/each}});
            {{/each}}
        }

        /// <summary>
        /// Indexer for the rows of this matrix.
        /// </summary>
        /// <param name="row">The row to select. Zero based.</param>
        [UnscopedRef]
        public ref {{@Name rowType}}<T> this[int row]
        {
            get
            {
                switch (row)
                {
                    {{each r in rows}}
                        case {{= r - 1}}:
                            return ref Row{{= r}};
                    {{/each}}
                }

                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Indexer for the values in this matrix.
        /// </summary>
        /// <param name="row">The row to select. Zero based.</param>
        /// <param name="column">The column to select. Zero based.</param>
        [UnscopedRef]
        public ref T this[int row, int column] => ref this[row][column];

        {{each r in rows}}
            {{each c in cols}}
                /// <summary>Gets the element in the {{@Ordinal r}} row and {{@Ordinal c}} column of the matrix.</summary>
                [DataMember]
                [UnscopedRef]
                public ref T M{{= r}}{{= c}} => ref Row{{= r}}.{{= Vector.VectorFieldNames[c - 1]}};

            {{/each}}
        {{/each}}
        /// <inheridoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public override bool Equals(object? obj) => obj is {{@Name thisType}}<T> other && Equals(other);

        /// <inheridoc/>
        public bool Equals({{@Name thisType}}<T> other) => this == other;

        /// <inheridoc/>
        public override int GetHashCode() => HashCode.Combine({{each r in rows}}Row{{= r}}{{delimit}}, {{/each}});

        {{
            var transposeSize = new Dimension(Rows: size.Columns, Columns: size.Rows);
        }}
        {{if model.AllSizes.Contains(transposeSize)}}
            {{
                var transposeType = new { Name = "Matrix", Size = transposeSize };
            }}
            /// <summary>Computes the transpose of the matrix.</summary>
            public {{@Name transposeType}}<T> Transpose() =>
                new({{each c in cols}}new({{each r in rows}}M{{= r}}{{= c}}{{delimit}}, {{/each}}){{delimit}},
                    {{/each}});

        {{/if}}
        /// <summary>Returns a boolean indicating whether the given two matrices are equal.</summary>
        /// <param name="left">The first matrix to compare.</param>
        /// <param name="right">The second matrix to compare.</param>
        /// <returns><c>true</c> if the given matrices are equal; <c>false</c> otherwise.</returns>
        public static bool operator ==({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) =>
            {{each r in rows}}left.Row{{= r}} == right.Row{{= r}}{{delimit}} &&
            {{/each}};

        /// <summary>Returns a boolean indicating whether the given two matrices are not equal.</summary>
        /// <param name="left">The first matrix to compare.</param>
        /// <param name="right">The second matrix to compare.</param>
        /// <returns><c>true</c> if the given matrices are not equal; <c>false</c> otherwise.</returns>
        public static bool operator !=({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) => !(left == right);

        /// <summary>Adds two matrices together.</summary>
        /// <param name="left">The first source matrix.</param>
        /// <param name="right">The second source matrix.</param>
        /// <returns>The result of the addition.</returns>
        public static {{@Name thisType}}<T> operator +({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) =>
            new({{each r in rows}}left.Row{{= r}} + right.Row{{= r}}{{delimit}},
                {{/each}});

        /// <summary>Subtracts the second matrix from the first.</summary>
        /// <param name="left">The first source matrix.</param>
        /// <param name="right">The second source matrix.</param>
        /// <returns>The result of the subtraction.</returns>
        public static {{@Name thisType}}<T> operator -({{@Name thisType}}<T> left, {{@Name thisType}}<T> right) =>
            new({{each r in rows}}left.Row{{= r}} - right.Row{{= r}}{{delimit}},
                {{/each}});

        /// <summary>Returns a new matrix with the negated elements of the given matrix.</summary>
        /// <param name="value">The source matrix.</param>
        /// <returns>The negated matrix.</returns>
        public static {{@Name thisType}}<T> operator -({{@Name thisType}}<T> value) =>
            new({{each r in rows}}-value.Row{{= r}}{{delimit}},
                {{/each}});

        {{each mul in model.MultiplyOperators}}
            {{
                var middleSize = mul.Left.Columns;
                var outputSize = new Dimension(mul.Left.Rows, mul.Right.Columns);
                var outputType = new { Name = "Matrix", Size = outputSize };
                var leftType = new { Name = "Matrix", Size = mul.Left };
                var rightType = new { Name = "Matrix", Size = mul.Right };
            }}
            /// <summary>Multiplies a matrix by another matrix.</summary>
            /// <param name="left">The first source matrix.</param>
            /// <param name="right">The second source matrix.</param>
            /// <returns>The result of the multiplication.</returns>
            public static {{@Name outputType}}<T> operator *({{@Name leftType}}<T> left, {{@Name rightType}}<T> right) =>
                new({{each r in Enumerable.Range(1, outputSize.Rows)}}{{each m in Enumerable.Range(1, middleSize)}}left.M{{= r}}{{= m}} * right.Row{{= m}}{{delimit}} + {{/each}}{{delimit}},
                    {{/each}});
        {{delimit}}

        {{/each}}
    }

    public static partial class {{@Name thisType}}
    {
        /// <summary>Linearly interpolates between the corresponding values of two matrices.</summary>
        /// <param name="value1">The first source matrix.</param>
        /// <param name="value2">The second source matrix.</param>
        /// <param name="amount">The relative weight of the second source matrix.</param>
        /// <returns>The interpolated matrix.</returns>
        public static {{@Name thisType}}<T> Lerp<T>({{@Name thisType}}<T> value1, {{@Name thisType}}<T> value2, T amount)
            where T : IFloatingPointIeee754<T> =>
            new({{each r in rows}}{{@Name rowType}}.Lerp(value1.Row{{= r}}, value2.Row{{= r}}, amount){{delimit}},
                {{/each}});
    }
}
